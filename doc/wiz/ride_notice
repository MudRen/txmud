1. 关于涉及坐骑编程时应注意的问题.

     ***坐骑物件必须在create()里 set(ride,1) (/obj/ride/horse.c 是一个例子)
	可以设定 ride_msg & unride_msg 作为上下坐骑的显示,如没设
	就用 ride & unride 里的默认信息

     ***可以设定 ride_level 作为有人骑上他以后的此人 apply/dodge 的
	修正值.也就是这匹坐骑的等级。如：set("ride_level",2);

	1,2	为普通的 4 级坐骑，骑这类坐骑没有骑术的限制。
	3,4,5	为 3 级坐骑，骑这类坐骑要求骑术不低于30。
	6,7,8	为 2 级坐骑，骑这类坐骑要求骑术不低于100。
	9,10	为 1 级坐骑，骑这类坐骑要求骑术不低于150。

价格: 坐骑物件可以设定 set("value",int); 作为这匹坐骑的价格,设定和
      商品物价的设定一样.如果坐骑没有设定 value ,此坐骑价值就按系统
      默认的坐骑价值计算.
      默认的坐骑价值:
	ride_level		value
	1			2000
	2			2500
	3			3000
	4			4000
	5			5000
	6			6000
	7			9000
	8			11000
	9			20000
	10			25000

add_action() 里应注意的问题.

     ***if( player->query_temp("on_rided") )
	可以判断出 player = this_player() 是否骑着坐骑,返回0 则没有骑.

     ***如需将 player = this_player() 的坐骑一起移过去可以用以下语句:

	if( ride = player->query_temp("on_rided") )    // 找出玩家的坐骑物件.
		ride->move(...);  // 将坐骑移过去
	player->move(...);	// 将 player 移过去

     ***如果遇到和坐骑一起过去不合理的地方,如 climb tree,climb 峭壁 等
	可用以下语句将 player = this_player() 强制 unride .

	if( player->query_temp("on_rided") )  // 判断是否骑着坐骑
		UNRIDE_CMD->main(player);     // 强制 unride.
	或者依据实际情况作出提示不能骑坐骑过去

     ***涉及到 valid_leave 需要玩家身上有什么标记才能过去的地方,要加
	一个判断: if(userp(player)) ,要不就把他的坐骑留在外面了.

     ***如遇到骑坐骑不能进入的房间以前要在入口编制valid_leave()进行判断,
	如果此房间有好几个出口那编程简直就是一个灾难而且还容易出错,因此
	增加一个房间设置: set("NORIDE","此处可写上禁止ride进入的提示信息"),
	也可以 set("NORIDE",1) 而用系统的默认提示信息:

		obj->query("short")+"可不能骑着坐骑去呀。\n" (obj为此房间物件)

	为了趣味性建议编程者用自己的提示信息为好.
	请注意: "NORIDE" 一定要大写.

	有个例子: /d/china/junying/shuaizhang.c

By Find.